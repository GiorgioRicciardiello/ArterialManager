<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>4-Direction Image Compare</title>
<style>
  :root { color-scheme: dark; }
  body { margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial; background:#111; color:#ddd; }
  .app { display:grid; grid-template-columns: 280px 1fr; height:100vh; }
  .sidebar { border-right:1px solid #333; overflow:auto; padding:12px; }
  .main { display:flex; flex-direction:column; height:100vh; }
  .topbar { padding:10px 12px; border-bottom:1px solid #333; display:flex; gap:12px; align-items:center; }
  .grid { display:grid; grid-template-columns: repeat(2, minmax(180px, 1fr)); gap:8px; }
  .slot { background:#181818; border:1px dashed #444; border-radius:10px; padding:8px; text-align:center; }
  .slot h4 { margin:6px 0 8px; font-size:12px; color:#aaa; }
  .drop { background:#0b0b0b; border:1px solid #2a2a2a; border-radius:8px; padding:8px; min-height:90px; display:flex; align-items:center; justify-content:center; color:#777; }
  .thumb { display:flex; align-items:center; gap:8px; padding:6px; border:1px solid #333; border-radius:8px; margin:6px 0; cursor:pointer; background:#151515; }
  .thumb img { width:56px; height:56px; object-fit:cover; border-radius:6px; }
  .thumb .name { overflow:hidden; text-overflow:ellipsis; white-space:nowrap; }
  .canvas-wrap { position:relative; flex:1; display:flex; align-items:center; justify-content:center; background:#0e0e0e; }
  canvas { max-width:100%; max-height:100%; background:#000; }
  .bar { position:absolute; background:#ff3b30; box-shadow:0 0 0 1px #000 inset; }
  .bar.v { width:3px; cursor:ew-resize; }
  .bar.h { height:3px; cursor:ns-resize; }
  .controls { display:grid; grid-template-columns:repeat(4,1fr); gap:10px; padding:10px 12px; border-top:1px solid #333; }
  .controls label { font-size:12px; color:#aaa; display:block; margin-bottom:4px; }
  input[type="range"] { width:100%; }
  .pill { padding:4px 8px; border:1px solid #333; border-radius:999px; font-size:12px; color:#bbb; }
  .hint { color:#8a8a8a; font-size:12px; margin-top:6px; }
  .btn { padding:6px 10px; border:1px solid #444; background:#1b1b1b; color:#ddd; border-radius:8px; cursor:pointer; }
</style>
</head>
<body>
<div class="app">
  <aside class="sidebar">
    <h3>Gallery</h3>
    <div class="hint">Pick a folder or drop files. Click a thumb, then drop onto a slot.</div>
    <div style="margin:10px 0;">
      <input id="folder" type="file" webkitdirectory multiple />
    </div>
    <div style="margin:8px 0;">
      <input id="files" type="file" multiple accept="image/*" />
    </div>
    <div id="thumbs"></div>
  </aside>

  <section class="main">
    <div class="topbar">
      <span class="pill">Center + 4 overlays</span>
      <button class="btn" id="fit">Fit</button>
      <button class="btn" id="reset">Reset bars</button>
      <span class="hint">Bars = red. Drag to reveal Top/Right/Bottom/Left overlays.</span>
    </div>

    <div style="padding:10px 12px;">
      <div class="grid">
        <div class="slot" data-slot="center">
          <h4>Center (Base)</h4>
          <div class="drop" draggable="false">Drop or click to assign</div>
        </div>
        <div class="slot" data-slot="top">
          <h4>Top overlay</h4>
          <div class="drop">Drop or click</div>
        </div>
        <div class="slot" data-slot="left">
          <h4>Left overlay</h4>
          <div class="drop">Drop or click</div>
        </div>
        <div class="slot" data-slot="right">
          <h4>Right overlay</h4>
          <div class="drop">Drop or click</div>
        </div>
        <div class="slot" data-slot="bottom">
          <h4>Bottom overlay</h4>
          <div class="drop">Drop or click</div>
        </div>
      </div>
    </div>

    <div class="canvas-wrap" id="wrap">
      <canvas id="cv"></canvas>
      <div class="bar v" id="barL"></div>
      <div class="bar v" id="barR"></div>
      <div class="bar h" id="barT"></div>
      <div class="bar h" id="barB"></div>
    </div>

    <div class="controls">
      <div>
        <label>Top opacity</label>
        <input type="range" id="alphaTop" min="0" max="1" step="0.05" value="1" />
      </div>
      <div>
        <label>Right opacity</label>
        <input type="range" id="alphaRight" min="0" max="1" step="0.05" value="1" />
      </div>
      <div>
        <label>Bottom opacity</label>
        <input type="range" id="alphaBottom" min="0" max="1" step="0.05" value="1" />
      </div>
      <div>
        <label>Left opacity</label>
        <input type="range" id="alphaLeft" min="0" max="1" step="0.05" value="1" />
      </div>
    </div>
  </section>
</div>

<script>
/* ---------- State ---------- */
const state = {
  images: [],           // {name, blobURL, img}
  assign: { center:null, top:null, right:null, bottom:null, left:null },
  bars: { L:0.33, R:0.67, T:0.33, B:0.67 }, // relative 0..1
  alphas: { top:1, right:1, bottom:1, left:1 },
  fitScale: 1
};

/* ---------- DOM ---------- */
const thumbs = document.getElementById('thumbs');
const wrap = document.getElementById('wrap');
const cv = document.getElementById('cv');
const ctx = cv.getContext('2d');
const barL = document.getElementById('barL');
const barR = document.getElementById('barR');
const barT = document.getElementById('barT');
const barB = document.getElementById('barB');
const alphaIds = ['Top','Right','Bottom','Left'];

/* ---------- Loaders ---------- */
async function filesToImages(fileList) {
  const files = [...fileList].filter(f => f.type.startsWith('image/'));
  for (const f of files) {
    const url = URL.createObjectURL(f);
    const img = await loadImage(url);
    state.images.push({ name:f.name, blobURL:url, img });
  }
  renderThumbs();
}

function loadImage(url) {
  return new Promise((res, rej) => {
    const im = new Image();
    im.onload = () => res(im);
    im.onerror = rej;
    im.src = url;
  });
}

/* ---------- Thumbs & Assign ---------- */
function renderThumbs() {
  thumbs.innerHTML = '';
  state.images.forEach((it, idx) => {
    const el = document.createElement('div');
    el.className = 'thumb';
    el.draggable = true;
    el.addEventListener('dragstart', ev => {
      ev.dataTransfer.setData('text/plain', idx.toString());
    });
    el.addEventListener('click', () => pendingAssign = idx);

    const img = document.createElement('img');
    img.src = it.blobURL;

    const name = document.createElement('div');
    name.className = 'name';
    name.textContent = it.name;

    el.appendChild(img);
    el.appendChild(name);
    thumbs.appendChild(el);
  });
}

let pendingAssign = null;

document.querySelectorAll('.slot').forEach(slot => {
  const key = slot.dataset.slot;
  const drop = slot.querySelector('.drop');

  slot.addEventListener('dragover', e => e.preventDefault());
  slot.addEventListener('drop', e => {
    e.preventDefault();
    const idx = +e.dataTransfer.getData('text/plain');
    assignTo(key, idx);
  });
  drop.addEventListener('click', () => {
    if (pendingAssign != null) assignTo(key, pendingAssign);
  });
});

function assignTo(slotKey, idx) {
  state.assign[slotKey] = idx;
  updateSlotPreview(slotKey);
  draw();
}

function updateSlotPreview(key) {
  const slot = document.querySelector(`.slot[data-slot="${key}"] .drop`);
  const idx = state.assign[key];
  if (idx == null) { slot.textContent = 'Drop or click to assign'; return; }
  const it = state.images[idx];
  slot.innerHTML = `<img src="${it.blobURL}" style="max-width:100%;max-height:120px;border-radius:6px">`;
}

/* ---------- Bars & Drawing ---------- */
function setCanvasToCenter() {
  const cIdx = state.assign.center;
  if (cIdx == null) return;
  const base = state.images[cIdx].img;
  // Fit base inside wrap with integer canvas size
  const W = wrap.clientWidth - 40;
  const H = wrap.clientHeight - 40;
  const s = Math.min(W / base.width, H / base.height);
  state.fitScale = s;
  cv.width = Math.round(base.width * s);
  cv.height = Math.round(base.height * s);
}

function draw() {
  const cIdx = state.assign.center;
  if (cIdx == null) { ctx.clearRect(0,0,cv.width,cv.height); return; }
  setCanvasToCenter();

  const base = state.images[cIdx].img;
  const s = state.fitScale, W = cv.width, H = cv.height;

  ctx.clearRect(0,0,W,H);
  ctx.drawImage(base, 0, 0, base.width, base.height, 0, 0, W, H);

  const getImg = k => state.assign[k] != null ? state.images[state.assign[k]].img : null;
  const I = { top:getImg('top'), right:getImg('right'), bottom:getImg('bottom'), left:getImg('left') };

  // draw helper
  const drawScaled = (img, sx, sy, sw, sh, dx, dy, dw, dh, alpha=1) => {
    if (!img || sw<=0 || sh<=0 || dw<=0 || dh<=0) return;
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.drawImage(img, sx/s, sy/s, sw/s, sh/s, dx, dy, dw, dh);
    ctx.restore();
  };

  const xL = Math.round(W * state.bars.L);
  const xR = Math.round(W * state.bars.R);
  const yT = Math.round(H * state.bars.T);
  const yB = Math.round(H * state.bars.B);

  // Left overlay: [0 .. xL)
  drawScaled(I.left, 0, 0, xL, H, 0, 0, xL, H, state.alphas.left);
  // Right overlay: [xR .. W)
  drawScaled(I.right, xR, 0, W - xR, H, xR, 0, W - xR, H, state.alphas.right);
  // Top overlay: [0 .. yT)
  drawScaled(I.top, 0, 0, W, yT, 0, 0, W, yT, state.alphas.top);
  // Bottom overlay: [yB .. H)
  drawScaled(I.bottom, 0, yB, W, H - yB, 0, yB, W, H - yB, state.alphas.bottom);

  // Bars
  positionBars();
}

function positionBars() {
  const W = cv.width, H = cv.height;
  const rect = cv.getBoundingClientRect();
  const wrapRect = wrap.getBoundingClientRect();
  const offX = (wrapRect.width - W)/2;
  const offY = (wrapRect.height - H)/2;

  const pxL = Math.round(W * state.bars.L) + offX;
  const pxR = Math.round(W * state.bars.R) + offX;
  const pxT = Math.round(H * state.bars.T) + offY;
  const pxB = Math.round(H * state.bars.B) + offY;

  Object.assign(barL.style, { left: pxL+'px', top: offY+'px', height: H+'px' });
  Object.assign(barR.style, { left: pxR+'px', top: offY+'px', height: H+'px' });
  Object.assign(barT.style, { left: offX+'px', top: pxT+'px', width: W+'px' });
  Object.assign(barB.style, { left: offX+'px', top: pxB+'px', width: W+'px' });
}

/* ---------- Drag bars ---------- */
function makeDrag(bar, type) {
  let dragging = false;
  bar.addEventListener('mousedown', e => { dragging = true; e.preventDefault(); });
  window.addEventListener('mouseup', () => dragging = false);
  window.addEventListener('mousemove', e => {
    if (!dragging) return;
    const rect = cv.getBoundingClientRect();
    if (type === 'L') {
      const x = Math.min(Math.max(0, e.clientX - rect.left), rect.width);
      state.bars.L = x / rect.width;
    } else if (type === 'R') {
      const x = Math.min(Math.max(0, e.clientX - rect.left), rect.width);
      state.bars.R = x / rect.width;
    } else if (type === 'T') {
      const y = Math.min(Math.max(0, e.clientY - rect.top), rect.height);
      state.bars.T = y / rect.height;
    } else if (type === 'B') {
      const y = Math.min(Math.max(0, e.clientY - rect.top), rect.height);
      state.bars.B = y / rect.height;
    }
    draw();
  });
}
makeDrag(barL,'L'); makeDrag(barR,'R'); makeDrag(barT,'T'); makeDrag(barB,'B');

/* ---------- Opacity sliders ---------- */
alphaIds.forEach(id => {
  const el = document.getElementById('alpha'+id);
  el.addEventListener('input', () => {
    state.alphas[id.toLowerCase()] = parseFloat(el.value);
    draw();
  });
});

/* ---------- Fit/Reset ---------- */
document.getElementById('fit').onclick = () => { setCanvasToCenter(); draw(); };
document.getElementById('reset').onclick = () => {
  state.bars = { L:0.33, R:0.67, T:0.33, B:0.67 };
  draw();
};

/* ---------- File inputs ---------- */
document.getElementById('folder').addEventListener('change', e => filesToImages(e.target.files));
document.getElementById('files').addEventListener('change', e => filesToImages(e.target.files));

/* ---------- Resize ---------- */
window.addEventListener('resize', () => { setCanvasToCenter(); draw(); });

</script>
</body>
</html>
